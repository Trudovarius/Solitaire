/*
 *
 * Hra Solitaire pre predmet IJA (Seminář Java) VUT FIT 2017
 * 
 * @author Rudolf Kučera     - xkucer91
 * @author Richard Činčura   - xcincu00
 *
 */

package ija.ija2016;
import java.awt.Component;
import java.util.Stack;

import ija.ija2016.Move.pile;
import ija.ija2016.board.*;
import ija.ija2016.cards.*;

/**
 * Class for move.
 * 
 * @param pile from   -  from what pile shall the cards be taken
 * @param pile to     -  to what pile they should be placed
 * @param int count   -  amount of cards moved
 * 
 * @param int Score   -  the amount of points generated by this move (only used by undo)
 */
public class Move {
	pile from;
	pile to;
	int count;
	
	int Score;
	
	/**
	 * Constructs the object.
	 * Initializes the data.
	 * count to 1 (1 card should be moved)
	 * from and to variables are null
	 */
	public Move() {
		this.count = 1;
	}
	
	/**
	 * This enum represents the piles
	 * 
	 * w1, w2 .... w7  are the workpiles
	 * h - heap
	 * d - dump
	 * t1, t2 ... t4 are the target piles
	 */
	public static enum pile {
		w1, w2, w3, w4, w5, w6, w7, t1, t2, t3, t4, h, d
	}
	
	/**
	 * This function interprets the move user does.
	 * Move.count cards are moved from pile Move.from to pile Move.to .
	 * 
	 * When the player moves 1 card, the cards is not taken from the pile but instead function 
	 * (Work|Target|Heap|Dump)Pile.peek() is used so that the card stays there.
	 * @see WorkPile.peek()
	 * The game then tries to put the card in the Move.to pile.
	 * If the (Work|Target|Heap|Dump)Pile.put() function returns true, the card from the Move.from pile 
	 * is now at place and is also removed from the first pile.
	 * 
	 * When more cards are moved, all cards are taken at once from the Move.from pile, stored in the
	 * Stack<Card> cards variable and then one by one (Work|Target|Heap|Dump)Pile.put() to the Move.to pile.
	 * If the put() function returns false, all the cards are placed back and nothing is done.
	 * 
	 * If the move was completed succesfully, the Score is computed and the move is saved to Game.moves stack.
	 * @see Game.moves 
	 *
	 * @param Game g - the game with the move
	 */
	public void move(Game g) {
		boolean fail = false;
		if (this.count == 1) {
			if (this.from == this.to) {
				this.to = this.from = null;
				this.count = 1;
				return;				
			}
			Card c;
			WorkPile w = null;
			TargetPile t = null;
			DumpPile d = null;
			switch (this.from) {
				case w1: c = g.work[0].peek(); w = g.work[0]; break;
				case w2: c = g.work[1].peek(); w = g.work[1]; break;
				case w3: c = g.work[2].peek(); w = g.work[2]; break;
				case w4: c = g.work[3].peek(); w = g.work[3]; break;
				case w5: c = g.work[4].peek(); w = g.work[4]; break;
				case w6: c = g.work[5].peek(); w = g.work[5]; break;
				case w7: c = g.work[6].peek(); w = g.work[6]; break;
				case t1: c = g.target[0].peek(); t = g.target[0]; break;
				case t2: c = g.target[1].peek(); t = g.target[1]; break;
				case t3: c = g.target[2].peek(); t = g.target[2]; break;
				case t4: c = g.target[3].peek(); t = g.target[3]; break;
				case h : c = g.heap.peek(); break;
				case d : c = g.dump.peek(); d = g.dump; break;			
				default: c = null;
			}
			boolean put;
			if (c == null) {
				this.to = this.from = null;
				this.count = 1;
				return;
			}
			switch (this.to) {
				case w1: put = g.work[0].put(c); break;
				case w2: put = g.work[1].put(c); break;
				case w3: put = g.work[2].put(c); break;
				case w4: put = g.work[3].put(c); break;
				case w5: put = g.work[4].put(c); break;
				case w6: put = g.work[5].put(c); break;
				case w7: put = g.work[6].put(c); break;
				case t1: put = g.target[0].put(c); break;
				case t2: put = g.target[1].put(c); break;
				case t3: put = g.target[2].put(c); break;
				case t4: put = g.target[3].put(c); break;
				default: c = null; put = true;
			}
			if (put) {
				if (w != null) {
					w.get(g);
				}
				if (t != null) {
					t.get();
				}
				if (d != null) {
					d.get();
				}
			} else {
				fail = true;
			}
		} else {
			if (this.from == this.to || !this.checkValidCards(g)) {
				this.to = this.from = null;
				this.count = 1;
				return;				
			}
			Stack<Card> cards = new Stack<Card>();
			WorkPile w;
			switch (this.from) {
				case w1: cards = g.work[0].getNCards(g, this.count); w = g.work[0]; break;
				case w2: cards = g.work[1].getNCards(g, this.count); w = g.work[1]; break;
				case w3: cards = g.work[2].getNCards(g, this.count); w = g.work[2]; break;
				case w4: cards = g.work[3].getNCards(g, this.count); w = g.work[3]; break;
				case w5: cards = g.work[4].getNCards(g, this.count); w = g.work[4]; break;
				case w6: cards = g.work[5].getNCards(g, this.count); w = g.work[5]; break;
				case w7: cards = g.work[6].getNCards(g, this.count); w = g.work[6]; break;
				default: cards = null; w = null;
			}
			boolean put;
			for (int i = 0; i < this.count; i++) {
				if (!cards.peek().isFaceUp()) {
					this.to = this.from = null;
					this.count = 1;
					return;
				}
				switch (this.to) {
					case w1: put = g.work[0].put(cards.peek()); break;
					case w2: put = g.work[1].put(cards.peek()); break;
					case w3: put = g.work[2].put(cards.peek()); break;
					case w4: put = g.work[3].put(cards.peek()); break;
					case w5: put = g.work[4].put(cards.peek()); break;
					case w6: put = g.work[5].put(cards.peek()); break;
					case w7: put = g.work[6].put(cards.peek()); break;
					default: cards = null; put = false;
				}
				if (!put) {
					if (!w.isEmpty())
						w.peek().setFaceDown();
					int S;
					if (cards != null) 
						S=  cards.size();
					else 
						S = 0;
					for (int x = 0;  x < S; x++) {
						w.push(cards.pop());
					}
					break;
				} else {
					cards.pop();
				}
			}
		}
		int Score = 0;
		// Waste to Tableau +5
		if (this.from == pile.d && (this.to== pile.w1 || this.to== pile.w2 || this.to== pile.w3 || this.to== pile.w4 || 
			this.to== pile.w5 || this.to== pile.w6 || this.to== pile.w7)) {
			Score = 5;
		}
		// Waste/Table to Foundation +10
		if (this.to == pile.t1 || this.to == pile.t2 ||this.to == pile.t3 ||this.to == pile.t4) {
			Score = 10;
		}
		// Foundation to Tableau -15
		if ((this.from == pile.t1 || this.from == pile.t2 ||this.from == pile.t3 ||this.from == pile.t4) &&
			(this.to== pile.w1 || this.to== pile.w2 || this.to== pile.w3 || this.to== pile.w4 || 
			this.to== pile.w5 || this.to== pile.w6 || this.to== pile.w7)) {
			Score = -15;
		}
		// Turn over Tableau card +5  ->  inside WorkPile.java function get()		
		g.incScore(Score);
		if (!fail) {
			// ulozenie tahu pre undo
			Move m = new Move();
			m.from = this.from;
			m.to = this.to;
			m.count = this.count;
			m.Score = Score;
			g.addMove(m);
		}
		this.to = this.from = null;
		this.count = 1;
	}
	
	/**
	 * This function checks if the cards are valid.
	 * This function DOES NOT CHECK if the cards are completely valid for the move.
	 * More other checks are performed in other places, this function handles only some of the errors.
	 *
	 * @param Game g   - game where the move is performed
	 *
	 * @return true if the cards passed the check, else false (no move is performed)
	 */
	private boolean checkValidCards(Game g) {
		WorkPile w;
		switch (this.from) {
			case w1: w = g.work[0]; break;
			case w2: w = g.work[1]; break;
			case w3: w = g.work[2]; break;
			case w4: w = g.work[3]; break;
			case w5: w = g.work[4]; break;
			case w6: w = g.work[5]; break;
			case w7: w = g.work[6]; break;
			default: return true;
		}
		if ( w.get(w.getSize() -this.count).isFaceUp() )
			return true;
		else
			return false;
	}

	/**
	 * Sets the from parameter.
	 * Translates String from into the enum pile.
	 * @see Move.pile
	 *
	 * @param String from - the string representing a pile
	 */
	public void setFrom(String from) {
    	switch (from) {
    		case "w1": this.from = pile.w1; break;
    		case "w2": this.from = pile.w2; break;
    		case "w3": this.from = pile.w3; break;
    		case "w4": this.from = pile.w4; break;
    		case "w5": this.from = pile.w5; break;
    		case "w6": this.from = pile.w6; break;
    		case "w7": this.from = pile.w7; break;
    		case "t1": this.from = pile.t1; break;
    		case "t2": this.from = pile.t2; break;
    		case "t3": this.from = pile.t3; break;
    		case "t4": this.from = pile.t4; break;
    		case "h" : this.from = pile.h ; break;
    		case "d" : this.from = pile.d ; break;
    	}
	}
	
	/**
	 * Sets the to parameter.
	 * Translates String from into the enum pile.
	 *
	 * @param String to - the string representing a pile
	 */
	public void setTo(String to) {
		switch (to) {
			case "w1": this.to = pile.w1; break;
			case "w2": this.to = pile.w2; break;
			case "w3": this.to = pile.w3; break;
			case "w4": this.to = pile.w4; break;
			case "w5": this.to = pile.w5; break;
			case "w6": this.to = pile.w6; break;
			case "w7": this.to = pile.w7; break;
			case "t1": this.to = pile.t1; break;
			case "t2": this.to = pile.t2; break;
			case "t3": this.to = pile.t3; break;
			case "t4": this.to = pile.t4; break;
			case "h" : this.to = pile.h ; break;
			case "d" : this.to = pile.d ; break;
		}
	}
}
